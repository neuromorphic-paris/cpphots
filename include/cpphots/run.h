/**
 * @file run.h
 * @brief Utilities functions for event processing
 */
#ifndef CPPHOTS_RUN_H
#define CPPHOTS_RUN_H

#include <vector>
#include <string>
#include <utility>

#include "layer.h"
#include "network.h"
#include "classification.h"


namespace cpphots {

/**
 * @brief Generic event processing function
 * 
 * Process a sequence of events using a generic processor class.
 * 
 * A processor is something with the following methods:
 * 
 *   - void reset()
 *   - Events process(const event&, bool)
 * 
 * Both Layer and Network satisfy the requirements.
 * 
 * @tparam P processor type
 * @param processor the processor
 * @param events events
 * @param reset true if processor.reset() should be called
 * @param skip_check if true consider all events as valid
 * @return events emitted by the processor
 */
template<typename P>
Events process(P& processor, const Events& events, bool reset = true, bool skip_check = false) {

    if (reset) {
        processor.reset();
    }

    Events ret;
    for (const auto& ev : events) {
        auto rev = processor.process(ev, skip_check);
        if (rev != invalid_event)
            ret.push_back(rev);
    }

    return ret;

}

/**
 * @brief Generic event processing function
 * 
 * Process a sequence of events using a generic processor class.
 * 
 * A processor is something with the following methods:
 * 
 *   - void reset()
 *   - Events process(const event&, bool)
 * 
 * Both Layer and Network satisfy the requirements.
 * 
 * @tparam P processor type
 * @param processor the processor
 * @param events sequences of events
 * @param reset true if processor.reset() should be called
 * @param skip_check if true consider all events as valid
 * @return corresponding sequences of events emitted by the processor
 */
template<typename P>
std::vector<Events> process(P& processor, const std::vector<Events>& events, bool reset = true, bool skip_check = false) {

    std::vector<Events> ret;

    for (const auto& evts : events) {
        ret.push_back(process(processor, evts, reset, skip_check));
    }

    return ret;

}


/**
 * @brief Generate all possible time surface from a list of events
 * 
 * Events are processed in order and the times surfaces generate correspond to that order.
 * 
 * A time surface calculator is something with the following methods:
 * 
 *   - void reset()
 *   - std::pair<TimeSurfaceType, bool> updateAndCompute(const event& ev)
 * 
 * TimeSurfaceCalculator, TimeSurfacePoolCalculator and Layer satisfy the requirements.
 * 
 * @tparam TSC time surface calculator type
 * @param calculator time surface calculator
 * @param events sequence of events
 * @param reset true if calculator.reset() should be called
 * @param skip_check if true consider all events as valid
 * @return time surfaces computed
 */
template <typename TSC>
std::vector<TimeSurfaceType> generateTS(TSC& calculator, const Events& events, bool reset = true, bool skip_check = false) {

    if (reset) {
        calculator.reset();
    }

    std::vector<TimeSurfaceType> ret;

    for (const auto& ev : events) {
        auto [ts, good] = calculator.updateAndCompute(ev);
        if (good || skip_check) {
            ret.push_back(ts);
        }
    }

    return ret;

}

/**
 * @brief Generate all possible time surface from sequences of events
 * 
 * Events are processed in order and the times surfaces generate correspond to that order.
 * 
 * A time surface calculator is something with the following methods:
 * 
 *   - void reset()
 *   - std::pair<TimeSurfaceType, bool> updateAndCompute(const event& ev)
 * 
 * TimeSurfaceCalculator, TimeSurfacePoolCalculator and Layer satisfy the requirements.
 * 
 * @tparam TSC time surface calculator type
 * @param calculator time surface calculator
 * @param events sequences of events
 * @param reset true if calculator.reset() should be called
 * @param skip_check if true consider all events as valid
 * @return corresponding sequences of time surfaces computed
 */
template <typename TSC>
std::vector<std::vector<TimeSurfaceType>> generateTS(TSC& calculator, const std::vector<Events>& events, bool reset = true, bool skip_check = false) {

    std::vector<std::vector<TimeSurfaceType>> ret;

    for (const auto& evts : events) {
        ret.push_back(generateTS(calculator, evts, reset, skip_check));
    }

    return ret;

}


/**
 * @brief Seed and train layers in a network
 * 
 * This function seeds the centroids of each layer and then train the layer with the events,
 * in a layer-by-layer sequence.
 * 
 * @param network the newtork
 * @param training_events events
 * @param seeding a clustering seeding function
 * @param skip_check if true consider all events as valid
 * @return events generated by the last layer of the network
 */
Events train(Network& network, Events training_events, const ClustererSeedingType& seeding, bool skip_check = false);

/**
 * @brief Seed and train layers in a network
 * 
 * This function seeds the centroids of each layer and then train the layer with the events,
 * in a layer-by-layer sequence.
 * 
 * @param network the newtork
 * @param training_events sequences of events
 * @param seeding a clustering seeding function
 * @param use_all if true use all sequence to seed the centroids (all sequences will used for training regardless)
 * @param skip_check if true consider all events as valid
 * @return events generated by the last layer of the network
 */
std::vector<Events> train(Network& network, std::vector<Events> training_events, const ClustererSeedingType& seeding, bool use_all = true, bool skip_check = false);

}

#endif